<!DOCTYPE html>
<html>
<head>
    <title>Think, wait, code</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Oswald:200&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./css/styles.css">
</head>

<body>
    <div class="container">
        <h1><a href="index.html">Think, wait, code</a></h1>
        <section id="menu">
            <nav>
                <a href="projects.html">Projects</a>
                <a href="writing.html">Writing</a>
                <a href="index.html">About</a>
            </nav>
        </section>
        <section id="info"></section>
        <section id="content">
            <h1>The perfect language</h1>
            <p>
                I secretly play with the idea of using retirement years to build the ultimate FPL - Functional Programming language. The one to rule them all and monadically bind them. It will have the performance of C, the expressivity of Haskell combined with the simplicity of Lisp. Interpreted and compiled, with no GC and zero cost abstractions. The magnificence of the tooling and eco system will rival that of the language itself. It will be, of course, cross platform.
            </p>
            <p>
                Flocks of developers will seek comfort under its shelter and a kind, enlightened community will arise. It will be awesome.
            </p>

            <p>
                Alas, if it was that easy better developers than me would have done the deed by now. The idea of a high performance FPL is hardly novel and there is no shortage of developers actively pursuing or dreaming about it. But what is preventing this lofty endeavour from being accomplished? There is not a single answer to the question since FPL is an umbrella term for a number of languages that can differ significantly from each other.
            </p>

            <p>
                Generally speaking though, the main challenges revolve around going without GC, lazy evaluation and higher level functional constructs. Let´s elaborate a bit.
            </p>

            <h2>Garbage Collection? No, thanks</h2>
            <p>
                Arguably the biggest hurdle. In the absence of GC,  memory needs either to be released manually or the syntax must somehow allow a more or less implicit way of doing it. Manual memory management would clutter the syntax and diminish the abstractions so the implicit option seems preferable. The term "implicit" is used a bit loosely, meaning that without writing specific code to release the memory, the language enforces rules to release memory deterministically. In other words, static analysis of the the code should be enough to determine when to release memory. Morevover, the syntax should make it as obvious as possible to the eye. Turns out that building a viable, frictionless syntax for deterministic memory release is far from trivial, as the good <a href="https://www.rust-lang.org/">Rustacean folks</a> can attest.
            </p>
            <p>
                As if the problem was not difficult enough already, there is the matter of dealing with closures, defined as expressions that capture and track variables of a context even after it has gone out of scope. Closures are nowadays a commodity that is taken for granted in many languages, not just FPLs but OOPs as well. This is only possible thanks to GCs, which takes care of tracking references held by closures and decide when to release them. Without a GC, statically determining when variables captured in a closure can be released is a big issue.
            </p>
            <h2>Lazy evaluation</h2>
            <p>
                Here we find two diametrally opposed points of view. One says that lazy evaluation undermines predictability since expressions, with their acompanying memory usage, will only be evaluated when needed. Compilers like predictability since it allows them to reorganize code for optimal execution so it follows that performance is undermined as well.
            </p>
            <p>
                The other point of view would say that laziness is actually benefitial for performance since the cost of evaluating things is deferred till you need them, a pay-as-you-go of sorts. While this is theoretically sound, in terms of performance pure lazy languages have failed to deliver so far. The poster child of laziness would be Haskell, which regards program compilation as composing all code into one single expression and execution as evaluating it. Personally I think that laziness should be an opt in, rather than a default.
            </p>

            <h2>Higher level functional constructs</h2>
            <p>
                Not much to say here, higher functional abstractions simply tend to involve usage of function calls and objects. Or as the famous aphorism goes, <i>there is no problem in Computer Science that cannot be solved by another level of indirection</i>. Typical FP constructs like functors, applicative or monads revolve around creating wrappers types and functions to work with them. Compilers keep improving so we can have these abstractions for the lowest possible cost but the truth is they are still far from being zero cost abstractions.
            </p>

            <h2>The future</h2>
            <p>
                Presently, the Software Development industry seems to have reached a comfortable status quo with well defined niches. C++ and C still rule in the world of performance, real time and embedded. They will not go away, obviously. Not for long, long time at least. Considering their sheer volumes of existing code, often critical, they might well still be here some centuries from now. Everything else is more or less as it always has been with the industry machine regularly churning new languages and platforms mostly for the sake of the hype, rather than bringing a paradigm shift. Business, as usual.
            </p>

            <p>
                There is, however, a trend that seems to keep growing steadily. This is the continued addition of Functional Programming elements to the syntax of existing of new languages. Properly done, FP cuts down on bugs and lines of code while making solutions and code easier to design and reason about. The industry simply recognizes this fact and tries to leverage it. Hype and trends come and go but practicality still rules the world the software development, eventually what works is kept and what does not is discarded.
            </p>

            <p>
                By cumulative effect, this trend might one day end up ushering in that brave new day of high performance Functional Programming.
                A common opinion among developers is that this will not happen simply because C++ and C, for all their inconvenients, are too difficult to displace. Why move to a new paradigm when you have to keep dealing with a huge mass of existing legacy code anyway? But I think one does not preclude the other. In my opinion, the possibility of having high performance combine with memory safety, less code that is easier to reason about will simply outweight other considerations in many cases, enough for this new language to be labelled as mainstream, standar of the industry or just popular.
            </p>

            <p>
                There are many, many developers that support this thinking, the Rust community being the prime example. Maybe not an example of success, certainly not a full blown FPL yet. But still, it illustrates the point. As they say, where there is a will there is way. Developers can be very stubborn when bent on making an idea work so my belief is that no matter how many attempts it takes, eventually it will happen. Will we be here to see it? Who knows. But I am fairly sure that it will be awesome.
            </p>

        </section>
    </div>

</body>
</html>
